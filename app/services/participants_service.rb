class ParticipantsService

  def participants options={}
    project = options[:project]
    since = options[:since]
    if project
      ideas = Idea.where(project: project)
      comments = Comment.where(idea_id: ideas.ids)
      votes = Vote.where(votable_id: (ideas.ids + comments.ids))
      if since
        ideas = ideas.where('created_at::date >= (?)::date', since)
        comments = comments.where('created_at::date >= (?)::date', since)
        votes = votes.where('created_at::date >= (?)::date', since)
      end
      User.where(id: (ideas.distinct.pluck(:author_id) + comments.distinct.pluck(:author_id) + votes.distinct.pluck(:user_id)).uniq)
    else
      users = User
        .joins(:activities)
        .group('users.id')
      if since
        users.where("activities.acted_at::date >= ?", since)
      else
        users
      end
    end
  end


  ENGAGING_ACTIVITIES = [
    {item_type: 'Comment', action: 'created'},
    {item_type: 'Idea', action: 'published'},
    {item_type: 'Vote', action: 'idea_upvoted'},
    {item_type: 'Vote', action: 'idea_downvoted'}
  ]

  # Adapts the passed activities_scope to only take into account activities
  # that should truly be taken into account as actual activity generated by
  # the user. E.g. Creating a vote is a truly engaging activity, whereas
  # receiving project moderation rights is not
  def filter_engaging_activities activities_scope
    output = activities_scope
    ENGAGING_ACTIVITIES.each.with_index do |activity, i|
      if i == 0
        output = output.where(item_type: activity[:item_type], action: activity[:action])
      else
        output = output.or(
          activities_scope.where(item_type: activity[:item_type], action: activity[:action]))
      end
    end
    output
  end

end