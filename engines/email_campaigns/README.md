# EmailCampaigns

This engine
* Hosts email campaign definitions
* Host email templates for campaigns sent out internally
* Sends out emails or publish events that trigger emails in external tools/services
* Keeps track of all the state required to send out e-mails
* Provides APIs to let cl2-front configure it all

# Campaign

Campaign is a class that is not intended to be used directly. It is a unified model that should be subclassed to implement specific campaign.
A campaign is a dynamic e-mail messages that can define certain logic with respect to:

- When it should be sent
- Who receives it
- What should be sent
- How it should be sent
- What should be tracked about it

## `#generate_command`

The `generate_command` method should be implemented by every campaign. It receives `time` or `activity` as options, and returns the `command` Hash that will be used to send out the campaign.
As a minimum, the command should contain the `event_payload`.

## `#mailer_class`

If the campaign should be sent out internally, instead of by publishing an event to the event bus, the ActionMailer class should be returned from the optional `mailer_class` method.

## Hooks

Every campaign subclass can make use of the following 3 hooks. Here's a minimal example:

```ruby
mpdule EmailCampaigns
class Campaigns::DemoCampaign < Campaign
  before_send :demo_content_exists?
  recipient_filter :filter_new_users
  after_send :notify_demo_api

  # ...

  private

  def demo_content_exists? options={}
    time = options[:time]
    SomeApi.new_demo_content?(at: time)
  end

  def filter_new_users users_scope, options={}
    users_scope.where("registration_completed_at > ?", Time.now - 1.week)
  end

  def after_send command

  end

end
```

### `before_send`

Registered `before_send` actions are possibly passed `time` and `activity` options, depending on how the campaign is  triggered - through a schedule or through an activity trigger.

The `before_send` actions have 2 purposes:
* Run any code that would be needed before send a campaign
* Returning a falsy value to stop the campaign from being sent out, a truthy value to continue

### `recipient_filter`

Registered `recipient_filter` actions get passed a `users_scope` object, and can potentially filter the scope to more finely specify the campaign recipients.

### `after_send`

Registered `after_send` actions get passed the command generated by `generate_command`. This can be used to do campaign-specific cleanup or tracking.


## Concerns
### ActivityTriggerable
### Consentable
Include this concern when the user should be able to consent to receiving this campaign through their user profile. 

Campaigns implementing this can optionally implement the `consentable_roles` class method, returning an array of roles that are entitled to consent to this campaign. Returning an empty array, or not implementing the method, means that all users can consent.

For example:
```ruby
class SomeCampaign < Campaign
  include Consentable

  def self.consentable_roles
    ['admin', 'project_moderator']
  end
end
```

### ContentConfigurable
### Disableable
### RecipientConfigurable
### Schedulable
### SenderConfigurable
### Trackable